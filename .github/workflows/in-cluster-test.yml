name: In-Cluster Integration Tests

# ==============================================================================
# Reusable Workflow for In-Cluster Go Testing
# ==============================================================================
# This workflow can be called by other workflows to run Go integration tests
# in a Kubernetes cluster environment.
#
# Usage in other workflows:
#   jobs:
#     integration-tests:
#       uses: ./.github/workflows/in-cluster-test.yml
#       with:
#         test-path: "./tests/integration"
#         test-name: "integration-tests"
#         timeout: 600
# ==============================================================================

on:
  workflow_call:
    inputs:
      test-path:
        description: 'Path to test files (e.g., ./tests/integration)'
        required: true
        type: string
      test-name:
        description: 'Name for the test suite (used in job names and artifacts)'
        required: true
        type: string
      timeout:
        description: 'Timeout in seconds for test execution'
        required: false
        type: number
        default: 600
      image-tag:
        description: 'Docker image tag to use for testing'
        required: false
        type: string
        default: 'ci-test'
      namespace:
        description: 'Kubernetes namespace to use'
        required: false
        type: string
        default: 'intelligence-deepagents'
    secrets:
      BOT_GITHUB_TOKEN:
        required: false
      BOT_GITHUB_USERNAME:
        required: false
      AWS_ROLE_ARN:
        required: false

permissions:
  id-token: write      # Required for AWS OIDC authentication
  contents: read
  pull-requests: write

jobs:
  in-cluster-tests:
    name: ${{ inputs.test-name }} Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.BOT_GITHUB_TOKEN || github.token }}
      
      - name: Checkout zerotouch-platform
        uses: actions/checkout@v4
        with:
          repository: 'arun4infra/zerotouch-platform'
          path: 'zerotouch-platform'
          token: ${{ secrets.BOT_GITHUB_TOKEN || github.token }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-south-1
          mask-aws-account-id: true
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
      
      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build test image
        run: |
          docker build -f Dockerfile.test -t ide-orchestrator:${{ inputs.image-tag }} .
      
      - name: Create Kind configuration
        run: |
          # Ensure zerotouch-platform exists
          if [[ ! -d "zerotouch-platform" ]]; then
            echo "zerotouch-platform directory not found in workflow"
            exit 1
          fi
          
          # Setup Kind cluster using shared script
          ./scripts/ci/setup-kind-cluster.sh
      
      - name: Set up Kind cluster
        run: |
          # Kind cluster is already set up by the previous step
          echo "âœ… Kind cluster ready"
      
      - name: Load Docker image into Kind
        run: |
          kind load docker-image ide-orchestrator:${{ inputs.image-tag }} --name zerotouch-preview
      
      - name: Bootstrap platform
        env:
          BOT_GITHUB_USERNAME: ${{ secrets.BOT_GITHUB_USERNAME }}
          BOT_GITHUB_TOKEN: ${{ secrets.BOT_GITHUB_TOKEN }}
          TENANTS_REPO_NAME: ${{ secrets.TENANTS_REPO_NAME }}
        run: |
          # Bootstrap platform using shared script
          ./scripts/ci/bootstrap-platform.sh preview
      
      - name: Apply preview patches
        run: |
          # Apply patches using shared script
          ./scripts/ci/apply-patches.sh --force
      
      - name: Run pre-deploy diagnostics
        run: |
          # Run pre-deployment diagnostics
          chmod +x scripts/ci/pre-deploy-diagnostics.sh
          ./scripts/ci/pre-deploy-diagnostics.sh
      
      - name: Deploy service
        env:
          IMAGE_TAG: ${{ inputs.image-tag }}
          NAMESPACE: ${{ inputs.namespace }}
        run: |
          # Deploy the service using existing scripts
          ./scripts/ci/deploy.sh
      
      - name: Run database migrations
        env:
          NAMESPACE: ${{ inputs.namespace }}
        run: |
          # Run migrations using shared script
          ./scripts/ci/run-migrations.sh ${{ inputs.namespace }}
      
      - name: Run post-deploy diagnostics
        env:
          NAMESPACE: ${{ inputs.namespace }}
        run: |
          # Run post-deployment diagnostics
          chmod +x scripts/ci/post-deploy-diagnostics.sh
          ./scripts/ci/post-deploy-diagnostics.sh ${{ inputs.namespace }} ide-orchestrator
      
      - name: Run in-cluster tests
        env:
          TEST_PATH: ${{ inputs.test-path }}
          TEST_NAME: ${{ inputs.test-name }}
          TIMEOUT: ${{ inputs.timeout }}
          NAMESPACE: ${{ inputs.namespace }}
          # JWT secret for testing
          JWT_SECRET: "test-secret-key-for-ci-testing"
        run: |
          # Run tests using shared script
          ./scripts/ci/run-test-job.sh "${{ inputs.test-path }}" "${{ inputs.test-name }}" "${{ inputs.timeout }}" "${{ inputs.namespace }}" "${{ inputs.image-tag }}"
      
      - name: Comment PR with test results
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const testName = '${{ inputs.test-name }}';
            
            const body = `## âœ… ${testName} Tests Completed
            
            **Infrastructure:** In-Cluster Kubernetes (Kind + ArgoCD)
            **Test Path:** \`${{ inputs.test-path }}\`
            
            ðŸŽ‰ Tests completed successfully! Check the workflow logs for detailed results.
            
            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
      
      - name: Cleanup
        if: always()
        run: |
          # Get logs from failed pods for debugging
          if kubectl get pods -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --field-selector=status.phase=Failed -o name | grep -q .; then
            echo "=== Failed Pod Logs ==="
            kubectl get pods -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --field-selector=status.phase=Failed -o name | while read pod; do
              echo "--- Logs for $pod ---"
              kubectl logs $pod -n ${{ inputs.namespace }} || true
            done
          fi
          
          # Clean up test jobs
          kubectl delete jobs -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --ignore-not-found=true
          
          # Clean up the Kind cluster
          kind delete cluster --name zerotouch-preview || true