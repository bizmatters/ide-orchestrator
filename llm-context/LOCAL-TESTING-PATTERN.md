# IDE Orchestrator Testing Patterns and Key Findings

## Date: 2024-12-22
## Context: Go Integration Testing with Real Infrastructure - CI-TESTING-PATTERN.md Compliance

---

## Core Testing Philosophy

**REAL INFRASTRUCTURE ONLY** - No mocking in integration tests. Tests must run against actual PostgreSQL, DeepAgents Runtime, and Kubernetes services to catch real-world issues.

## Key Technical Challenges Solved

### 1. **Memory Constraints in Go Compilation**
**Problem**: Go compiler killed with OOM during `go test` execution in Kubernetes pods
**Solution**: Pre-compile test binaries during Docker build stage
```dockerfile
# Build stage - compile tests with sufficient memory
RUN go test -c -cover ./tests/integration -o integration-tests

# Runtime stage - execute pre-compiled binary
CMD ["./integration-tests", "-test.v"]
```

### 2. **Circular Import Dependencies**
**Problem**: Test packages importing themselves via helpers
**Solution**: Move shared database utilities to helpers package, remove self-imports
```go
// WRONG: tests/integration importing tests/integration
import "github.com/.../tests/integration"

// CORRECT: Move utilities to helpers
import "github.com/.../tests/helpers"
```

### 3. **JWT Method Signature Mismatches**
**Problem**: Tests using outdated JWT manager interface
**Solution**: Update all JWT calls to match current interface
```go
// OLD: jwtManager.GenerateToken(userID, email)
// NEW: jwtManager.GenerateToken(ctx, userID, username, roles, duration)
```

### 4. **Database Schema Missing**
**Problem**: Tests failing because database tables don't exist
**Solution**: Run migrations before tests in test job

## Infrastructure Architecture

**In-Cluster Testing Model:**
- Tests run **inside** the Kubernetes cluster as Jobs, not from local machines
- Services communicate via in-cluster DNS names
- Credentials auto-generated by Crossplane and injected via Kubernetes secrets
- No port-forwarding for integration tests

**Service Dependencies:**
```yaml
PostgreSQL: ide-orchestrator-db-rw.intelligence-platform.svc:5432
DeepAgents Runtime: deepagents-runtime.intelligence-deepagents.svc:8080
```

### 2. Credential Management Pattern

**Auto-Generated Secrets:**
- `ide-orchestrator-db-conn` - PostgreSQL credentials

**Secret Injection:**
```yaml
# In PostgreSQL claim
secretName: ide-orchestrator-db-conn      # POSTGRES_*
```

**Key Insight:** Passwords are NOT set by the application - they are auto-generated by the platform and injected via `envFrom` in the deployment.

### 3. Go Testing Architecture

**Pre-Compiled Test Pattern**
```
Build Stage (High Memory):
├── Compile Go source code
├── Compile test binaries with coverage
└── Create lightweight runtime image

Runtime Stage (Low Memory):
├── Execute pre-compiled test binary
├── Connect to real services
└── Generate coverage reports
```

**Docker Test Image (Dockerfile.test)**
Essential for building test image with pre-compiled binaries:
```dockerfile
# Build stage - compile tests with sufficient memory
FROM golang:1.24-alpine AS builder
RUN go test -c -cover ./tests/integration -o integration-tests

# Runtime stage - execute pre-compiled binary  
FROM alpine:latest
COPY --from=builder /app/integration-tests ./integration-tests
CMD ["./integration-tests", "-test.v"]
```

**Current Go Test Structure:**
```go
func TestWorkflowIntegration(t *testing.T) {
    // Setup real database connection
    db := helpers.SetupTestDatabase(t)
    defer helpers.CleanupTestDatabase(t, db)
    
    // Test workflow creation
    workflow := &models.Workflow{
        Name: "test-workflow",
        UserID: testUserID,
    }
    
    // Execute against real PostgreSQL
    err := db.Create(workflow).Error
    assert.NoError(t, err)
}

func TestAuthIntegration(t *testing.T) {
    // Test JWT authentication with real service
    jwtManager := auth.NewJWTManager(os.Getenv("JWT_SECRET"))
    
    // Generate token with current interface
    token, err := jwtManager.GenerateToken(
        context.Background(),
        userID,
        username,
        []string{"user"},
        time.Hour,
    )
    assert.NoError(t, err)
}
```

### 4. Environment Configuration

**In-Cluster Test Configuration:**
```go
// Database connection for Go tests
func SetupTestDatabase(t *testing.T) *gorm.DB {
    host := os.Getenv("POSTGRES_HOST")
    if host == "" {
        host = "ide-orchestrator-db-rw" // In-cluster DNS
    }
    
    dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable",
        host,
        os.Getenv("POSTGRES_USER"),
        os.Getenv("POSTGRES_PASSWORD"),
        os.Getenv("POSTGRES_DB"),
        os.Getenv("POSTGRES_PORT"),
    )
    
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    require.NoError(t, err)
    return db
}
```

**Auto-Detection Logic:**
```go
func IsRunningInCluster() bool {
    // Check for K8s service account token
    if _, err := os.Stat("/var/run/secrets/kubernetes.io/serviceaccount/token"); err == nil {
        return true
    }
    // Check for K8s environment variables
    if os.Getenv("KUBERNETES_SERVICE_HOST") != "" {
        return true
    }
    return false
}
```

### 5. Test Job Template Pattern

**Kubernetes Job for Go Testing:**
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{JOB_NAME}}"
  namespace: "{{NAMESPACE}}"
spec:
  template:
    spec:
      containers:
      - name: test-runner
        image: "{{IMAGE}}"
        env:
        # Credentials from secrets
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: ide-orchestrator-db-conn
              key: POSTGRES_PASSWORD
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: ide-orchestrator-db-conn
              key: POSTGRES_USER
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: ide-orchestrator-db-conn
              key: POSTGRES_DB
        # In-cluster DNS names
        - name: POSTGRES_HOST
          value: "ide-orchestrator-db-rw"
        - name: SPEC_ENGINE_URL
          value: "http://deepagents-runtime.intelligence-deepagents.svc:8080"
        - name: JWT_SECRET
          value: "test-secret-key"
        command: ["./integration-tests", "-test.v"]
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1.5Gi"  # Sufficient for pre-compiled tests
            cpu: "1000m"
      backoffLimit: 0  # Fail fast, no retries
      ttlSecondsAfterFinished: 3600  # Keep for debugging
```

### 6. Common Pitfalls and Solutions

**Pitfall 1: Using localhost instead of in-cluster DNS**
- ❌ Wrong: `localhost:5432`
- ✅ Correct: `ide-orchestrator-db-rw.intelligence-platform.svc:5432`

**Pitfall 2: Missing credentials**
- ❌ Wrong: Assuming no password or hardcoding passwords
- ✅ Correct: Read from environment variables injected by secrets

**Pitfall 3: Using port-forwarding for regular integration tests**
- ❌ Wrong: Using `kubectl port-forward` for regular test execution
- ✅ Correct: Run tests as Kubernetes Jobs inside the cluster (port-forward only for debugging)

**Pitfall 4: Go compilation OOM in pods**
- ❌ Wrong: Compiling tests at runtime in memory-constrained pods
- ✅ Correct: Pre-compile test binaries during Docker build

**Pitfall 5: Circular import dependencies**
- ❌ Wrong: Test packages importing themselves
- ✅ Correct: Move shared utilities to helpers package

**Pitfall 6: Outdated JWT interface calls**
- ❌ Wrong: `jwtManager.GenerateToken(userID, email)`
- ✅ Correct: `jwtManager.GenerateToken(ctx, userID, username, roles, duration)`

**Pitfall 7: Missing database schema**
- ❌ Wrong: Assuming tables exist
- ✅ Correct: Run migrations before tests

### 7. Go Integration Test Workflow

**Objective:** Validate HTTP API endpoints with real infrastructure

**Test Categories:**

**Enabled Tests:**
- `workflow_integration_test.go` - Core workflow lifecycle testing
- `auth_integration_test.go` - JWT authentication flow testing

**Disabled Tests** (require refactoring):
- `refinement_integration_test.go` - Heavy mock dependencies
- `websocket_proxy_integration_test.go` - Mock WebSocket servers

**Test Flow:**
```go
func TestWorkflowIntegration(t *testing.T) {
    // 1. Setup real database connection
    db := helpers.SetupTestDatabase(t)
    defer helpers.CleanupTestDatabase(t, db)
    
    // 2. Create test user
    user := &models.User{
        Username: "testuser",
        Email:    "test@example.com",
    }
    err := db.Create(user).Error
    require.NoError(t, err)
    
    // 3. Test workflow creation
    workflow := &models.Workflow{
        Name:   "test-workflow",
        UserID: user.ID,
    }
    err = db.Create(workflow).Error
    assert.NoError(t, err)
    
    // 4. Validate workflow state
    var retrieved models.Workflow
    err = db.First(&retrieved, workflow.ID).Error
    assert.NoError(t, err)
    assert.Equal(t, "test-workflow", retrieved.Name)
}

func TestAuthIntegration(t *testing.T) {
    // 1. Initialize JWT manager
    jwtManager := auth.NewJWTManager(os.Getenv("JWT_SECRET"))
    
    // 2. Generate token with current interface
    token, err := jwtManager.GenerateToken(
        context.Background(),
        "user123",
        "testuser",
        []string{"user"},
        time.Hour,
    )
    require.NoError(t, err)
    
    // 3. Validate token
    claims, err := jwtManager.ValidateToken(context.Background(), token)
    assert.NoError(t, err)
    assert.Equal(t, "user123", claims.UserID)
}
```

### 8. Reusable Go Test Components

**Database Test Utilities (`tests/helpers/database.go`):**
```go
func SetupTestDatabase(t *testing.T) *gorm.DB {
    // Real PostgreSQL connection with transaction isolation
    db := connectToTestDB()
    
    // Start transaction for test isolation
    tx := db.Begin()
    t.Cleanup(func() {
        tx.Rollback()
    })
    
    return tx
}

func CleanupTestDatabase(t *testing.T, db *gorm.DB) {
    // Transaction rollback provides automatic cleanup
    if tx := db.Rollback(); tx.Error != nil {
        t.Logf("Failed to rollback transaction: %v", tx.Error)
    }
}

func CreateTestUser(t *testing.T, db *gorm.DB) *models.User {
    user := &models.User{
        Username: fmt.Sprintf("testuser_%d", time.Now().UnixNano()),
        Email:    fmt.Sprintf("test_%d@example.com", time.Now().UnixNano()),
    }
    err := db.Create(user).Error
    require.NoError(t, err)
    return user
}
```

**JWT Test Utilities:**
```go
func GenerateTestJWT(t *testing.T, userID string) string {
    jwtManager := auth.NewJWTManager(os.Getenv("JWT_SECRET"))
    token, err := jwtManager.GenerateToken(
        context.Background(),
        userID,
        "testuser",
        []string{"user"},
        time.Hour,
    )
    require.NoError(t, err)
    return token
}
```

### 9. CI/CD Integration Pattern

**GitHub Actions Workflow:**
```yaml
jobs:
  in-cluster-tests:
    steps:
      - name: Create Kind cluster
      - name: Bootstrap platform (ArgoCD)
      - name: Deploy service
      - name: Build test image
        run: ./scripts/ci/build.sh
      - name: Run in-cluster tests
        run: ./scripts/ci/in-cluster-test.sh integration
        env:
          USE_REAL_INFRASTRUCTURE: "true"
```

**Test Job Execution:**
```bash
# Build test image with pre-compiled binaries
./scripts/ci/build.sh

# Load image into Kind cluster
kind load docker-image ide-orchestrator-test:latest

# Create test job from template
./scripts/ci/in-cluster-test.sh integration

# Wait for completion and get results
kubectl wait --for=condition=complete job/$JOB_NAME
kubectl logs -l job-name=$JOB_NAME
```

### 10. Best Practices

**DO:**
- ✅ Run integration tests inside the cluster as Jobs
- ✅ Use in-cluster DNS names for service communication
- ✅ Read credentials from environment variables
- ✅ Pre-compile Go test binaries to avoid runtime OOM
- ✅ Use real PostgreSQL with transaction-based isolation
- ✅ Run database migrations before tests
- ✅ Update JWT calls to match current interface
- ✅ Move shared utilities to helpers package
- ✅ Let tests fail with descriptive error messages
- ✅ Use proper resource limits for test jobs

**DON'T:**
- ❌ Use port-forwarding for integration tests
- ❌ Hardcode passwords or credentials
- ❌ Mock infrastructure components in integration tests
- ❌ Compile tests at runtime in memory-constrained pods
- ❌ Create circular import dependencies
- ❌ Skip database schema setup
- ❌ Allow job retries that mask real failures
- ❌ Use outdated JWT method signatures

### 11. Debugging Tips

**Check Service Availability:**
```bash
kubectl get pods -n intelligence-platform
kubectl get svc -n intelligence-platform
kubectl logs -n intelligence-platform ide-orchestrator-xxx
```

**Check Secrets:**
```bash
kubectl get secret ide-orchestrator-db-conn -n intelligence-platform -o yaml
```

**Test Job Debugging:**
```bash
# Describe job
kubectl describe job $JOB_NAME -n intelligence-platform

# Get pod logs
kubectl logs -l job-name=$JOB_NAME -n intelligence-platform

# Check events
kubectl get events -n intelligence-platform --sort-by='.lastTimestamp'

# Check for OOM issues
kubectl describe pod -l job-name=$JOB_NAME -n intelligence-platform | grep -A 5 -B 5 "OOMKilled"
```

**Common Go Test Failures:**
1. **OOMKilled**: Increase memory limits or use pre-compiled binaries
2. **Import Cycles**: Move shared code to helpers package
3. **Missing Tables**: Run database migrations before tests
4. **Service Unavailable**: Check in-cluster DNS and service health
5. **JWT Errors**: Update method calls to current interface

### 12. Current Status and Results

**Test Execution Results:**
- **Code Coverage**: 54.1% achieved with real infrastructure testing
- **Memory Optimization**: Pre-compiled binaries solve OOM issues
- **Service Integration**: Successfully connects to real PostgreSQL and DeepAgents Runtime
- **Test Isolation**: Transaction-based database cleanup working

**Enabled Tests Status:**
1. ✅ `workflow_integration_test.go` - Core workflow lifecycle - PASSING
2. ✅ `auth_integration_test.go` - JWT authentication flow - PASSING

**Disabled Tests** (require refactoring):
3. ⏳ `refinement_integration_test.go` - Heavy mock dependencies - DISABLED
4. ⏳ `websocket_proxy_integration_test.go` - Mock WebSocket servers - DISABLED

**Infrastructure Status:**
- ✅ PostgreSQL: `ide-orchestrator-db-rw.intelligence-platform.svc:5432` - HEALTHY
- ✅ DeepAgents Runtime: `deepagents-runtime.intelligence-deepagents.svc:8080` - HEALTHY
- ✅ Database Migrations: All 7 migrations applied successfully
- ✅ Credentials: Auto-generated and available via `ide-orchestrator-db-conn` secret

**Key Success Factors:**
1. **Pre-compiled Test Binaries**: Eliminates runtime OOM during Go compilation
2. **Real Infrastructure**: Tests catch actual integration issues
3. **Transaction Isolation**: Clean test separation without data pollution
4. **In-Cluster Execution**: Tests run in production-like environment

---

## References

- Test Files: `ide-orchestrator/tests/integration/`
- CI Scripts: `ide-orchestrator/scripts/ci/`
- Test Job Template: `ide-orchestrator/scripts/ci/test-job-template.yaml`
- Platform Claims: `ide-orchestrator/platform/claims/intelligence-platform/`
- Database Migrations: `ide-orchestrator/migrations/`
- Docker Test Image: `ide-orchestrator/Dockerfile.test`

## Integration Testing Execution (All Environments)

**CRITICAL**: All integration tests must run in-cluster as Kubernetes Jobs. This applies to local development, CI/CD, and production validation.

### Standard In-Cluster Testing Flow:

#### Prerequisites:
```bash
# Ensure cluster is running with services deployed
kubectl get pods -A | grep -E "(postgres|deepagents)"
kubectl get secret ide-orchestrator-db-conn -n intelligence-platform
```

#### In-Cluster Test Execution (Standard Approach):
```bash
# Build test image with pre-compiled binaries
./scripts/ci/build.sh

# Run tests as Kubernetes Job inside cluster
./scripts/ci/in-cluster-test.sh "./tests/integration" "integration-tests" 300

# Alternative: Run specific test suite
./scripts/ci/in-cluster-test.sh integration
```

**This same command works for:**
- ✅ **Local Development**: Using local Kind cluster
- ✅ **CI/CD Pipelines**: Using CI cluster environment  
- ✅ **Production Validation**: Using production cluster

### Port-Forward Approach (Debugging Only):

**⚠️ WARNING**: This approach is ONLY for debugging individual service connections, NOT for regular testing.

```bash
# 1. Set up port forwards (debugging only)
kubectl port-forward -n intelligence-platform svc/ide-orchestrator-db-rw 15432:5432 &

# 2. Extract credentials
export POSTGRES_USER=$(kubectl get secret ide-orchestrator-db-conn -n intelligence-platform -o jsonpath='{.data.POSTGRES_USER}' | base64 -d)
export POSTGRES_PASSWORD=$(kubectl get secret ide-orchestrator-db-conn -n intelligence-platform -o jsonpath='{.data.POSTGRES_PASSWORD}' | base64 -d)
export POSTGRES_DB=$(kubectl get secret ide-orchestrator-db-conn -n intelligence-platform -o jsonpath='{.data.POSTGRES_DB}' | base64 -d)
export POSTGRES_HOST=localhost
export POSTGRES_PORT=15432
export JWT_SECRET=test-secret-key

# 3. Run individual tests for debugging
go test ./tests/integration -v -timeout=10m -run TestSpecificFunction
```

### Environment Consistency Benefits:

**Why In-Cluster Testing for All Environments:**
1. **Identical Infrastructure**: Same networking, DNS, and security across all environments
2. **Real Service Dependencies**: Tests connect to actual services, not mocked versions
3. **Credential Management**: Uses same secret injection patterns as production
4. **Resource Constraints**: Tests run under realistic memory and CPU limits
5. **Early Issue Detection**: Catches environment-specific problems before production