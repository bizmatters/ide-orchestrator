name: Quality Gate

# This workflow acts as a quality gate that only succeeds when ALL other workflows pass.
# It automatically discovers and checks all workflows for the commit, excluding itself
# and the build-and-push workflow. This means you never need to update this file when
# adding new quality check workflows (linting, unit tests, security scans, etc.).

on:
  # Trigger after both test workflows complete
  workflow_run:
    workflows: ["Spec Generation Tests (In-Cluster)", "NATS Events Integration Tests"]
    types: [completed]
    branches: [main]
  # Allow manual trigger for testing
  workflow_dispatch:

permissions:
  actions: read
  contents: read

jobs:
  quality-gate:
    name: All Quality Checks Passed
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Get the commit SHA from triggering workflow
        id: get-sha
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          else
            echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Check all workflows passed (auto-discovery)
        uses: actions/github-script@v7
        env:
          COMMIT_SHA: ${{ steps.get-sha.outputs.sha }}
        with:
          script: |
            const sha = process.env.COMMIT_SHA;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            console.log(`üîç Checking workflow runs for commit: ${sha}`);
            
            // Get all workflow runs for this commit
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              head_sha: sha,
              per_page: 100
            });
            
            console.log(`üìä Found ${workflowRuns.workflow_runs.length} total workflow runs for this commit`);
            
            // Filter out this workflow and build-and-push workflow
            // All other workflows are considered quality checks that must pass
            const relevantWorkflows = workflowRuns.workflow_runs.filter(run => 
              run.name !== 'Quality Gate' && 
              run.name !== 'Build and Push Production Image'
            );
            
            console.log(`\nüéØ Checking ${relevantWorkflows.length} quality check workflow(s):\n`);
            
            if (relevantWorkflows.length === 0) {
              core.setFailed('‚ùå No quality check workflows found for this commit. Expected at least integration tests.');
              return;
            }
            
            // Check each workflow
            const failedWorkflows = [];
            const pendingWorkflows = [];
            const passedWorkflows = [];
            
            for (const run of relevantWorkflows) {
              const status = `${run.status} (${run.conclusion || 'in_progress'})`;
              
              if (run.status !== 'completed') {
                console.log(`‚è≥ ${run.name}: ${status}`);
                pendingWorkflows.push(run.name);
              } else if (run.conclusion !== 'success') {
                console.log(`‚ùå ${run.name}: ${status}`);
                failedWorkflows.push({ name: run.name, conclusion: run.conclusion });
              } else {
                console.log(`‚úÖ ${run.name}: ${status}`);
                passedWorkflows.push(run.name);
              }
            }
            
            console.log(`\nüìà Summary:`);
            console.log(`  ‚úÖ Passed: ${passedWorkflows.length}`);
            console.log(`  ‚ùå Failed: ${failedWorkflows.length}`);
            console.log(`  ‚è≥ Pending: ${pendingWorkflows.length}`);
            
            // Report results
            if (pendingWorkflows.length > 0) {
              core.setFailed(`‚è≥ Waiting for workflows to complete: ${pendingWorkflows.join(', ')}`);
              return;
            }
            
            if (failedWorkflows.length > 0) {
              const failures = failedWorkflows.map(w => `${w.name} (${w.conclusion})`).join(', ');
              core.setFailed(`‚ùå Quality gate failed. Failed workflows: ${failures}`);
              return;
            }
            
            console.log('\n‚úÖ All quality checks passed!');
            
            // Create summary
            core.summary
              .addHeading('Quality Gate: PASSED ‚úÖ')
              .addRaw(`All ${relevantWorkflows.length} quality check workflow(s) completed successfully for commit ${sha.substring(0, 7)}`)
              .addHeading('Workflow Results', 3);
            
            for (const name of passedWorkflows) {
              core.summary.addRaw(`\n- ‚úÖ ${name}`);
            }
            
            core.summary.write();
      
      - name: Quality gate summary
        if: success()
        run: |
          echo "‚úÖ All quality checks passed!"
          echo "Ready for production build and deployment."
